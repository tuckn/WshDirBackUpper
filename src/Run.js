/* globals Wsh: false */
/* globals process: false */

// Shorthands
var util = Wsh.Util;
var CD = Wsh.Constants;
var cli = Wsh.Commander;
var ConfigStore = Wsh.ConfigStore;
var dirBkup = Wsh.DirBackUpper; // Shorthand

var isSolidArray = util.isSolidArray;

/**
 * Below are the APIs of CLI (Command Line Interface). Some inappropriate titles are used because they are generated by JsDoc.
 *
 * @namespace CLI
 */

// backup {{{
/**
 * Back up the specifying directory.
 *
 * @example
 * Usage: backup <srcDir> <destDir> [options]
 *
 * The command to back up a directory
 *
 * Options:
 *   -V, --version                  Output the version number
 *   -S, --sync-method <method>     Synchronization method. "UPDATE" (default) or "MIRROR"
 *   -C, --comparison <method>      Comparison method. Default is "TIME" (modification date). otherwise "CONTENT" (MD5, slow)
 *   -R, --no-recursively           Excludes sub directories
 *   -P, --no-omit-empdir           Copies empty directories
 *   -L, --no-omit-symlink          Copies symbolic links
 *   -M, --matched-reg <expression> Matched files RegExp
 *   -I, --ignored-reg <expression> Ignored files RegExp
 *   -E, --no-ignore-err            Throw Error
 *   -L, --logger <val>             <level>/<transportation> (e.g. "warn/popup").  (default: "info/console")
 *   -R, --dry-run                  No execute. Outputs the string of command. (default: false)
 *   -h, --help                     Output usage information
 * @function backup
 * @memberof CLI
 */
cli.addProgram({
  command: 'backup <srcDir> <destDir>',
  description: 'The command to back up a directory',
  version: '2.2.0',
  options: [
    ['-S, --sync-method <method>', 'Synchronization method. "UPDATE" (default) or "MIRROR"'],
    ['-C, --comparison <method>', 'Comparison method. Default is "TIME" (modification date). otherwise "CONTENT" (MD5, slow)'],
    ['-R, --no-recursively', 'Excludes sub directories'],
    ['-P, --no-omit-empdir', 'Copies empty directories'],
    ['-L, --no-omit-symlink', 'Copies symbolic links'],
    ['-M, --matched-reg <expression>', 'Matched files RegExp'],
    ['-I, --ignored-reg <expression>', 'Ignored files RegExp'],
    ['-E, --no-ignore-err', 'Throw Error'],
    ['-L, --logger <val>', '<level>/<transportation> (e.g. "warn/popup"). ', 'info/console'],
    ['-R, --dry-run', 'No execute. Outputs the string of command.']
  ],
  action: function (srcDir, destDir, opt) {
    var rtn = dirBkup.backupDir(srcDir, destDir, {
      syncMethod: opt.syncMethod,
      comparison: opt.comparison,
      isRecursive: opt.recursively,
      copiesEmpDir: !opt.omitEmpdir,
      includesSymlink: !opt.omitSymlink,
      matchedRegExp: opt.matchedReg,
      ignoredRegExp: opt.ignoredReg,
      throws: !opt.ignoreErr,
      logger: opt.logger,
      isDryRun: opt.dryRun
    });

    if (opt.dryRun) console.log(rtn);

    process.exit(CD.runOk);
  }
}); // }}}

// archive {{{
/**
 * Compresses the directory into archive file (ZIP or RAR).
 *
 * @example
 * Usage: archive <srcDir> <dest> [options]
 *
 * The command to archive a directory
 *
 * Options:
 *   -V, --version                  Output the version number
 *   -A, --archive-type <type>  The archiving type, "ZIP" (default) or "RAR"
 *   -D, --date-code <expression>   If specify "yyyy-MM-dd", The dest name is <name>_yyyy-MM-dd.zip
 *   -C, --password <string>        Encrypt the archive file. File names will be not encrypted in Zip.
 *   -O, --compressLv <Lv>          Compression level. ZIP (1,3,5,7,9), RAR (0-store...3-default...5-maximal).
 *   -F, --no-forEach-subDir        Compresses each sub directory in the specified source directory.
 *   -P, --no-omit-empdir           Compresses empty directories
 *   -L, --no-omit-symlink          Compresses symbolic links
 *   -M, --matched-reg <expression> Matched RegExp only for the root directories and files in the source
 *   -I, --ignored-reg <expression> Ignored RegExp only for the root directories and files in the source
 *   -E, --no-ignore-err            Throw Error
 *   -L, --logger <val>             <level>/<transportation> (e.g. "warn/popup").  (default: "info/console")
 *   -R, --dry-run                  No execute. Outputs the string of command. (default: false)
 *   -h, --help                     Output usage information
 * @function archive
 * @memberof CLI
 */
cli.addProgram({
  command: 'archive <srcDir> <dest>',
  description: 'The command to archive a directory',
  version: '2.2.0',
  options: [
    ['-A, --archive-type <type>', 'The archiving type, "ZIP" (default) or "RAR"', 'ZIP'],
    ['-F, --no-forEach-subDir', 'Compresses each sub directory in the specified source directory.'],
    ['-P, --no-omit-empdir', 'Compresses empty directories'],
    ['-D, --date-code <expression>', 'If specify "yyyy-MM-dd", The dest name is <name>_yyyy-MM-dd.zip'],
    ['-C, --password <string>', 'Encrypt the archive file. File names will be not encrypted in Zip.'],
    ['-O, --compressLv <Lv>', 'Compression level. ZIP (1,3,5,7,9), RAR (0-store...3-default...5-maximal)'],
    ['-L, --no-omit-symlink', 'Compresses symbolic links'],
    ['-M, --matched-reg <expression>', 'Matched files RegExp'],
    ['-I, --ignored-reg <expression>', 'Ignored files RegExp'],
    ['-E, --no-ignore-err', 'Throw Error'],
    ['-L, --logger <val>', '<level>/<transportation> (e.g. "warn/popup"). ', 'info/console'],
    ['-R, --dry-run', 'No execute. Outputs the string of command.']
  ],
  action: function (srcDir, dest, opt) {
    var rtns = dirBkup.archiveDir(srcDir, dest, {
      archiveType: opt.archiveType,
      forEachSubDir: opt.forEachSubDir,
      dateCode: opt.dateCode,
      password: opt.password,
      compressLv: opt.compressLv,
      copiesEmpDir: !opt.omitEmpdir,
      includesSymlink: !opt.omitSymlink,
      matchedRegExp: opt.matchedReg,
      ignoredRegExp: opt.ignoredReg,
      throws: !opt.ignoreErr,
      logger: opt.logger,
      isDryRun: opt.dryRun
    });

    if (opt.dryRun) console.dir(rtns);

    process.exit(CD.runOk);
  }
}); // }}}

// schemaBackup {{{
/**
 * Back up directories defined with a schema JSON.
 *
 * @example
 * Usage: schemaBackup <taskName> [overwriteKey:val...] [options]
 *
 * The command to back up directories defined with a schema JSON
 *
 * Options:
 *   -V, --version          Output the version number
 *   -D, --dir-path <path>  The path name where the schema JSON is located. <Directory Path> or "cwd", "portable", "userProfile". Default: "cmd" is "%CD%\.wsh"
 *   -F, --file-name <name> A JSON file name. (default: "settings.json")
 *   -E, --encoding <name>  The JSON file encoding. (default: "utf-8")
 *   -N, --prop-name <name> A property name of the schema object. (default: "dirBackUpperSchema")
 *   -L, --logger <val>     <level>/<transportation>. e.g. "warn/popup".  (default: "info/console")
 *   -R, --dry-run          No execute. Outputs the string of command. (default: false)
 *   -h, --help             Output usage information
 * @function schemaBackup
 * @memberof CLI
 */
cli.addProgram({
  command: 'schemaBackup <taskName> [overwriteKey:val...]',
  description: 'The command to back up directories defined with a schema JSON',
  version: '2.2.0',
  options: [
    ['-D, --dir-path <path>', 'The path name where the schema JSON is located. <Directory Path> or "cwd", "portable", "userProfile". Default: "cmd" is "%CD%\\.wsh"'],
    ['-F, --file-name <name>', 'A JSON file name.', 'settings.json'],
    ['-E, --encoding <name>', 'The JSON file encoding.', CD.ado.charset.utf8],
    ['-N, --prop-name <name>', 'A property name of the schema object.', 'dirBackUpperSchema'],
    ['-L, --logger <val>', '<level>/<transportation>. e.g. "warn/popup". ', 'info/console'],
    ['-R, --dry-run', 'No execute. Outputs the string of command.']
  ],
  action: function (taskName, overwrites, opt) {
    var overwritesObj = {};
    if (isSolidArray(overwrites)) {
      overwrites.forEach(function (setStr) {
        var strs = setStr.split(':');
        if (strs.length > 1) overwritesObj[strs[0]] = strs.slice(1).join(':');
      });
    }

    var conf = new ConfigStore(opt.fileName, {
      dirPath: opt.dirPath,
      fileOptions: { encoding: opt.encoding }
    });
    var schema = conf.get(opt.propName);

    var rtn = dirBkup.backupDirUsingSchema(schema, taskName, {
      overwrites: overwritesObj,
      logger: opt.logger,
      isDryRun: opt.dryRun
    });

    if (opt.dryRun) console.log(rtn);
    process.exit(CD.runOk);
  }
}); // }}}

cli.parse(process.argv);
